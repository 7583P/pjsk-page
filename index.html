<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>PJSK LOUNGE</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#1e1e1e; --panel:#22252b; --panel2:#1b1e23; --ink:#fff; --muted:#bfc5d0;
      --brand:#6c6cf0; --warn:#f0a66c; --ok:#58d68d; --err:#ff6b6b; --line:#0006;
      --hover:#2f3541; --chip:#2a2f3a; --rowhLB:56px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:
      radial-gradient(1200px 600px at 10% -10%, rgba(108,108,240,.08), transparent 60%),
      radial-gradient(1200px 600px at 110% 10%, rgba(250,200,120,.05), transparent 60%),
      var(--bg);
      color:var(--ink);
      font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif}
    a{color:inherit;text-decoration:none}
    #app{min-height:100%}

    header.topbar{
      position:sticky;top:0;z-index:5;
      background:rgba(30,30,30,.7);
      backdrop-filter:saturate(1.4) blur(10px);
      border-bottom:1px solid #ffffff12
    }
    .topwrap{max-width:1100px;margin:0 auto;display:flex;align-items:center;gap:16px;padding:12px 16px}
    .brand{font-weight:800;letter-spacing:.4px}
    .brand::before{content:"◆";margin-right:8px;color:#8e88ff}
    nav.tabs{margin-left:auto;display:flex;gap:8px;flex-wrap:wrap}
    .tabbtn{
      padding:9px 14px;border-radius:12px;background:#0000;border:1px solid #ffffff18;color:var(--ink);
      cursor:pointer;transition:.15s ease-in-out; font-weight:600;
    }
    .tabbtn:hover{background:#ffffff10}
    .tabbtn.active{background:linear-gradient(135deg,#6c6cf0,#8e88ff);border-color:#0000;box-shadow:0 6px 18px rgba(108,108,240,.35)}
    .tabbtn[disabled]{opacity:.5;cursor:not-allowed}

    .container{max-width:1100px;margin:22px auto;padding:20px}
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid #ffffff12;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35);
      padding:18px
    }
    .grid{display:grid;gap:16px}
    .grid.cols-2{grid-template-columns:1fr 1fr}
    @media (max-width:980px){ .grid.cols-2{grid-template-columns:1fr} }

    .hero{text-align:center;padding:30px;border-radius:16px;background:
      radial-gradient(600px 280px at 20% 10%, rgba(108,108,240,.20), transparent 50%),
      radial-gradient(600px 280px at 80% 10%, rgba(240,166,108,.15), transparent 50%),
      linear-gradient(135deg,#20242c,#1c1f26);
      border:1px solid #ffffff18;margin-bottom:16px
    }
    .hero h1{font-size:clamp(28px,5vw,48px);margin:0 0 8px}
    .hero p{margin:0;color:var(--muted)}

    .field{display:flex;flex-direction:column;gap:6px;margin-bottom:12px}
    label{font-size:.92rem;color:var(--muted)}
    input, select{
      padding:12px 12px;border-radius:12px;border:1px solid #ffffff10;background:#0f1117;color:var(--ink);outline:none
    }
    input:focus, select:focus{border-color:#8e88ff}

    .btn{
      display:inline-flex;align-items:center;justify-content:center;gap:8px;padding:11px 16px;border-radius:12px;border:1px solid #ffffff18;
      background:linear-gradient(135deg,#6c6cf0,#8e88ff);color:#fff;cursor:pointer;font-weight:700;letter-spacing:.2px;
      box-shadow:0 8px 20px rgba(108,108,240,.28)
    }
    .btn.ghost{background:#10131a;border-color:#ffffff24;box-shadow:none}
    .btn.warn{background:linear-gradient(135deg,#f0a66c,#f7c28f);color:#000}
    .btn.full{width:100%}
    .btn.small{padding:7px 10px;font-size:.9rem}
    .btn.discord{background:#5865F2}
    .btn:active{transform:translateY(1px)}

    .help{font-size:.9rem;color:var(--muted)}
    .msg{padding:10px 12px;border-radius:12px;margin:10px 0;font-size:.95rem;border:1px solid #ffffff15}
    .msg.ok{background:#143624;color:#d6ffe7;border-color:#2a6c4b}
    .msg.err{background:#3b1e1e;color:#ffd6d6;border-color:#6c2a2a}
    .msg.info{background:#131a2e;color:#d6e4ff;border-color:#2a3f6c}
    .steps{display:grid;gap:10px;margin-top:10px}
    .step{padding:12px;border-radius:14px;border:1px solid #ffffff14;background:#0e1118;display:flex;align-items:center;justify-content:space-between;gap:12px}
    .badge{padding:5px 10px;border-radius:999px;background:#2a2f3a}
    .badge.ok{background:#1e3b2e;color:#bff5d2;border:1px solid #2a6c4b}

    section{display:none}
    section.active{display:block}

    /* ================== LEADERBOARD ================== */
    #lbApp {max-width: 1000px;margin: 0 auto;padding: 0;background-color: transparent;}
    #lbApp h1 {font-size: 2em;margin-bottom: 20px;text-align: center;}
    #lbApp .controls {margin-bottom: 15px;text-align: center;}
    #lbApp input[type="text"] {
      padding: 5px;width: 80%;max-width: 400px;border: none;border-radius: 4px;text-align: center;background: #555;color: #fff;
    }

    #lbApp .dropdown {position: relative;display: inline-block;margin-left: 10px}
    #lbApp .dropbtn {
      background: #737373;border: none;padding: 6px 12px;cursor: pointer;border-radius: 8px;color: #fff;font-weight: 700;white-space: nowrap;
    }
    #lbApp .dropdown-content {
      display: none;position: absolute;top: 120%;left: 0;min-width: 260px;background-color: #2e2e2e;border:1px solid #0006;
      box-shadow: 0 8px 24px rgba(0,0,0,.35);z-index: 1000;border-radius: 10px;overflow: hidden;
    }
    #lbApp .dropdown-content a {
      display: block;padding: 10px 12px;text-decoration: none;font-size: 14px;white-space: nowrap;color: #fff;
    }
    #lbApp .dropdown-content a:hover {background:#3a3a3a}

    /* Gradientes para textos */
    #lbApp .text-gradient, #lbApp .name-gradient{
      display:inline-block;background-clip:text;-webkit-background-clip:text;-webkit-text-fill-color:transparent;
    }
    #lbApp .name-gradient .emoji{background:none !important;-webkit-background-clip:initial !important;-webkit-text-fill-color: currentColor !important}

    #lbApp table {width: 100%;border-collapse: collapse;margin-top: 10px}
    #lbApp th, #lbApp td {padding: 10px;text-align: center;color: #fff}
    #lbApp th {background-color: #030050}
    #lbApp td {border-bottom: 1px solid #555}
    #lbApp tbody tr:nth-child(odd)  {background-color: #333}
    #lbApp tbody tr:nth-child(even) {background-color: #2a2a2a}

    /* Posición + bandera + PFP */
    #lbApp .position-cell {
      position: relative;text-align: center;padding-right: 120px;height: var(--rowhLB);
    }
    #lbApp .position-cell .position-number {display: inline-block}
    #lbApp .position-cell .flag {
      width: 24px; position: absolute; top: 50%; right: 72px; transform: translateY(-50%);
      border-radius: 3px; box-shadow: 0 0 0 1px #0008;
    }
    #lbApp .position-cell .pfp-sq{
      position:absolute;top:50%;right:8px;transform:translateY(-50%);
      width:calc(var(--rowhLB) - 12px);height:calc(var(--rowhLB) - 12px);
      border-radius:8px;border:1px solid #0007;object-fit:cover;background:#111
    }

    /* Rangos (degradado dere → izq) */
    .rank-Placement   { background-image: linear-gradient(to left, #ff7000, #ff4600); }
    .rank-Iron        { background-image: linear-gradient(to left, #616161, #2e2e2e); }
    .rank-Bronze      { background-image: linear-gradient(to left, #6d2a00, #3d1d00); }
    .rank-Silver      { background-image: linear-gradient(to left, #b3b3b3, #696969); }
    .rank-Gold        { background-image: linear-gradient(to left, #ffbf60, #c57600); }
    .rank-Platinum    { background-image: linear-gradient(to left, #767ec2, #38429f); }
    .rank-Diamond     { background-image: linear-gradient(to left, #42a2ff, #003e8f); }
    .rank-Crystal     { background-image: linear-gradient(to left, #dca3ff, #883cb4); }
    .rank-Master      { background-image: linear-gradient(to left, #c34efd, #5f009e); }
    .rank-Champion    { background-image: linear-gradient(to left, #fe6767, #8f0000); }
    .rank-GrandChampion { background-image: linear-gradient(to left, #ff0800, #570300); white-space: nowrap; }
    .rank-Legend      { background-image: linear-gradient(to left, #c9f4ff, #c9f4ff); }

    #lbApp .pagination {margin-top: 15px;display:flex;justify-content:center;align-items:center;gap:8px}
    #lbApp .pagination button {
      padding: 4px 8px;border: none;border-radius: 4px;background: #555;color: #fff;cursor: pointer;
    }
    #lbApp .pagination button:disabled {opacity: .4;cursor: default}
    #lbApp .pagination input[type="number"] {
      width: 50px; padding: 4px; text-align: center; border-radius: 4px;border: 1px solid #555; background: #2a2a2a; color: #fff;
    }

    /* ===== PFP Picker ===== */
    .pfp-toolbar{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-bottom:12px}
    .pfp-grid{display:grid;grid-template-columns:repeat(6, 1fr);gap:10px}
    @media (max-width:1100px){ .pfp-grid{grid-template-columns:repeat(5,1fr)} }
    @media (max-width:900px){ .pfp-grid{grid-template-columns:repeat(4,1fr)} }
    @media (max-width:680px){ .pfp-grid{grid-template-columns:repeat(3,1fr)} }
    @media (max-width:480px){ .pfp-grid{grid-template-columns:repeat(2,1fr)} }
    .card-tile{background:#0f1117;border:1px solid #ffffff10;border-radius:12px;overflow:hidden;cursor:pointer;transition:.15s transform, .15s box-shadow}
    .card-tile:hover{transform:translateY(-2px); box-shadow:0 10px 18px rgba(0,0,0,.25)}
    .tile-img{width:100%;aspect-ratio:1/1;object-fit:cover;display:block;background:#0a0c11}
    .tile-meta{padding:8px;font-size:.85rem;color:#ddd;display:flex;justify-content:space-between;gap:8px}
    .danger{color:#ffb3b3}
  </style>
</head>
<body>
<div id="app">
  <header class="topbar">
    <div class="topwrap">
      <div class="brand">PJSK LOUNGE</div>
      <nav class="tabs" id="tabs">
        <button class="tabbtn active" data-tab="home">Home</button>
        <button class="tabbtn" data-tab="leaderboard">Leaderboard</button>
        <!-- SIEMPRE clickeable -->
        <button class="tabbtn" id="tabProfile" data-tab="profile">Edit Profile</button>
      </nav>
    </div>
  </header>

  <main class="container">
    <!-- HOME -->
    <section id="home" class="active">
      <div class="hero card">
        <h1>Welcome to PJSK LOUNGE</h1>
        <p>PJSK competitive — Discord Bot + Page.</p>
      </div>

      <div id="configError" class="card msg err" style="display:none"></div>

      <div id="authArea" class="grid cols-2">
        <!-- Login -->
        <div class="card">
          <h2 style="margin:0 0 10px">Log in</h2>
          <div class="field">
            <label for="loginDiscord">Discord username o Showname</label>
            <input id="loginDiscord" type="text" placeholder="usuario123 o usuario#0001" />
          </div>
          <div class="field">
            <label for="loginEmail">Email</label>
            <input id="loginEmail" type="email" placeholder="usuario123@email.com" autocomplete="username" />
          </div>
          <div class="field">
            <label for="loginPass">Contraseña</label>
            <input id="loginPass" type="password" placeholder="••••••••" autocomplete="current-password" />
          </div>
          <button id="btnLogin" class="btn full">Entrar</button>
          <div class="oauth-row" style="display:flex;gap:8px;flex-wrap:wrap;margin-top:10px">
            <button id="btnLoginDiscord" class="btn discord">Vincular con Discord</button>
          </div>
          <div style="display:flex;justify-content:space-between;align-items:center;margin-top:10px;gap:8px;flex-wrap:wrap">
            <button id="btnReset" class="btn ghost">Reset password</button>
            <button id="btnResendFromLogin" class="btn ghost">Reenviar verificación email</button>
          </div>
          <div id="loginMsg"></div>
        </div>

        <!-- Register -->
        <div class="card">
          <h2 style="margin:0 0 10px">Register</h2>
          <div class="field">
            <label for="regDiscord">Discord username o Showname</label>
            <input id="regDiscord" type="text" placeholder="usuario123 o usuario#0001" />
          </div>
          <div class="field">
            <label for="regEmail">Email</label>
            <input id="regEmail" type="email" placeholder="usuario123@email.com" autocomplete="email" />
          </div>
          <div class="field">
            <label for="regPass">Contraseña</label>
            <input id="regPass" type="password" placeholder="Mínimo 6 caracteres" autocomplete="new-password" />
          </div>
          <button id="btnRegister" class="btn full">Crear cuenta</button>
          <div class="oauth-row" style="display:flex;gap:8px;flex-wrap:wrap;margin-top:10px">
            <button id="btnRegisterDiscord" class="btn discord">Vincular con Discord</button>
          </div>
          <div id="regMsg"></div>
        </div>
      </div>

      <!-- Pasos de verificación -->
      <div id="welcomeArea" class="card" style="display:none">
        <h2 style="margin:0 0 6px">¡Hola, <span id="welcomeName">usuario123</span>!</h2>
        <div class="steps">
          <div class="step">
            <div>
              <strong>1) Verificación de Discord</strong><br>
              <span class="help">Opción A: Conecta tu Discord. Opción B: DM al bot <code>/verify <span id="discCode">------</span></code></span>
            </div>
            <div style="display:flex;gap:8px;align-items:center">
              <span id="discBadge" class="badge">Pendiente</span>
              <button id="btnCopyCode" class="btn small ghost">Copiar código</button>
              <button id="btnRegenCode" class="btn small ghost">Re-generar</button>
            </div>
          </div>
          <div class="step">
            <div>
              <strong>2) Verificación de Email (5 min)</strong><br>
              <span class="help">Se envía un correo y caduca en <span id="emailTimer">—:—</span>.</span>
            </div>
            <div style="display:flex;gap:8px;align-items:center">
              <span id="mailBadge" class="badge">Pendiente</span>
              <button id="btnResendVerify" class="btn small warn">Reenviar email</button>
              <button id="btnIHaveVerified" class="btn small ghost">Ya verifiqué</button>
            </div>
          </div>
          <div class="step">
            <div>
              <strong>Acceso a Edit PFP</strong><br>
              <span class="help">Se habilita cuando <b>Discord</b> esté verificado.</span>
            </div>
            <div>
              <button id="btnGoProfile" class="btn small">Ir a Edit Profile</button>
              <button id="btnLogout" class="btn small ghost">Log out</button>
            </div>
          </div>
        </div>
        <div id="welcomeMsg"></div>
      </div>
    </section>

    <!-- LEADERBOARD -->
    <section id="leaderboard">
      <div class="card">
        <div id="lbApp">
          <h1>PJSK LOUNGE – Season {{ seasonLabel }}</h1>

          <div class="controls">
            <input type="text" v-model="filter" placeholder="Buscar por nombre…" v-if="!selectedRank">

            <!-- Dropdown de Rangos -->
            <div class="dropdown" @click.stop>
              <button class="dropbtn" @click.stop="menuOpen = !menuOpen">
                <template v-if="selectedRank">
                  <span :class="['text-gradient','rank-'+selectedRank]">{{ displayRank(selectedRank) }}</span>
                  <span> ({{ filteredCount }}) ▾</span>
                </template>
                <template v-else>
                  <span class="text-gradient rank-Legend">Rangos ▾</span>
                </template>
              </button>
              <div id="rankList" class="dropdown-content" v-show="menuOpen">
                <a v-for="r in ranks" :key="r.key" href="#" @click.prevent="selectRank(r.key)">
                  <span :class="['text-gradient','rank-'+r.key]">{{ r.label }}</span>
                </a>
              </div>
            </div>

            <button v-if="selectedRank"
                    @click="clearRank"
                    style="margin-left:10px; background:#555; color:#fff; padding:6px 12px; border:none; border-radius:8px; cursor:pointer;">
              Mostrar todo
            </button>
          </div>

          <table>
            <thead>
              <tr><th>#</th><th>Player</th><th>MMR</th><th>Rango</th></tr>
            </thead>
            <tbody>
              <tr v-for="p in paginatedPlayers" :key="p.id" :style="{height:'var(--rowhLB)'}">
                <td class="position-cell">
                  <span :class="['position-number','text-gradient','rank-'+p.rank]">{{ playerRankMap[p.id] }}</span>
                  <img v-if="p.country" :src="flagUrl(p.country)" :alt="p.country" class="flag" />
                  <img v-if="pfpMap[p.name?.toLowerCase?.()]" :src="pfpMap[p.name.toLowerCase()]" alt="pfp" class="pfp-sq" />
                </td>
                <td>
                  <span :class="['name-gradient','rank-'+p.rank]">
                    <template v-for="(seg, idx) in splitName(p.name)" :key="idx">
                      <span v-if="seg.isEmoji" class="emoji">{{ seg.char }}</span>
                      <span v-else>{{ seg.char }}</span>
                    </template>
                  </span>
                  <span v-if="p.verified === false || p.discordVerified === false || p.dv === false" class="fail" style="color:#ff6b6b;margin-left:8px;font-size:12px;">failed to verificate</span>
                </td>
                <td><span :class="['text-gradient','rank-'+p.rank]">{{ p.mmr }}</span></td>
                <td><span :class="['text-gradient','rank-'+p.rank]">{{ displayRank(p.rank) }}</span></td>
              </tr>
            </tbody>
          </table>

          <div class="pagination">
            <button @click="prevPage" :disabled="currentPage<=1">&laquo;</button>
            <input type="number" v-model.number="currentPage" @keyup.enter="goToPage" :min="1" :max="totalPages" />
            <span>/ {{ totalPages }}</span>
            <button @click="nextPage" :disabled="currentPage>=totalPages">&raquo;</button>
          </div>
        </div>
      </div>
    </section>

    <!-- PROFILE: Set PFP -->
    <section id="profile">
      <div class="card">
        <h2 style="margin:0 0 10px">Set PFP</h2>

        <div id="profileGate" class="msg info" style="display:none">
          You must be registered/logged in and link your Discord to edit your PFP.
        </div>

        <div id="profileContent">
          <p class="help" style="margin:0 0 12px">
            Selecciona cualquier carta (normal / entrenada). Si el catálogo no carga, pega una URL manual.
          </p>
          <div class="pfp-toolbar">
            <input id="pfpSearch" type="text" placeholder="Buscar por nombre, id, asset..." style="min-width:260px">
            <select id="pfpVersion">
              <option value="both">Mostrar: ambas versiones</option>
              <option value="normal">Solo no entrenada</option>
              <option value="trained">Solo entrenada</option>
            </select>
            <button id="btnClearPfp" class="btn warn">Eliminar PFP</button>
          </div>
          <div id="pfpInfo" class="msg info" style="display:none"></div>
          <div id="pfpGrid" class="pfp-grid"></div>
          <div class="field" style="margin-top:12px">
            <label>Fallback manual (si la lista no carga)</label>
            <div style="display:flex;gap:10px;flex-wrap:wrap">
              <input id="manualUrl" type="text" placeholder="https://...png" style="min-width:360px;flex:1">
              <button id="btnSetManual" class="btn">Usar esta imagen</button>
            </div>
            <span class="help danger">Usa imágenes cuadradas 1:1 para encajar perfecto.</span>
          </div>
        </div>
      </div>
    </section>
  </main>
</div>

<!-- Vue + Axios para Leaderboard -->
<script src="https://unpkg.com/vue@3"></script>
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
<script>
  const { createApp } = Vue;

  createApp({
    data(){
      return {
        players: [],
        filter: '',
        playerRankMap: {},
        currentPage: 1,
        pageSize: 50,
        selectedRank: null,
        menuOpen: false,
        pfpMap: {},  // nameLower -> url
        ranks: [
          { key:'Iron',          label:'Iron (↓0-100)' },
          { key:'Bronze',        label:'Bronze (101-200)' },
          { key:'Silver',        label:'Silver (201-300)' },
          { key:'Gold',          label:'Gold (301-400)' },
          { key:'Platinum',      label:'Platinum (401-500)' },
          { key:'Diamond',       label:'Diamond (501-600)' },
          { key:'Crystal',       label:'Crystal (601-700)' },
          { key:'Master',        label:'Master (701-800)' },
          { key:'Champion',      label:'Champion (801-900)' },
          { key:'GrandChampion', label:'GrandChampion (901-999)' },
          { key:'Legend',        label:'Legend (↑1000)' }
        ]
      }
    },
    computed:{
      filteredPlayers(){
        let list = this.players;
        if (this.selectedRank) list = list.filter(p => p.rank === this.selectedRank);
        else if (this.filter) {
          const q = this.filter.toLowerCase();
          list = list.filter(p => (p.name||'').toLowerCase().includes(q));
        }
        return list;
      },
      filteredCount(){
        if(!this.selectedRank) return 0;
        return this.players.filter(p => p.rank === this.selectedRank).length;
      },
      totalPages(){ return Math.max(1, Math.ceil(this.filteredPlayers.length / this.pageSize)); },
      paginatedPlayers(){
        const start = (this.currentPage - 1) * this.pageSize;
        return this.filteredPlayers.slice(start, start + this.pageSize);
      },
      seasonLabel(){ return 'Beta'; }
    },
    watch:{
      filter(){ this.currentPage = 1; },
      selectedRank(){ this.currentPage = 1; this.filter = ''; },
      currentPage(val){
        if(val < 1) this.currentPage = 1;
        else if (val > this.totalPages) this.currentPage = this.totalPages;
      }
    },
    methods:{
      selectRank(rank){ this.selectedRank = rank; this.menuOpen = false; },
      clearRank(){ this.selectedRank = null; },
      prevPage(){ if(this.currentPage > 1) this.currentPage--; },
      nextPage(){ if(this.currentPage < this.totalPages) this.currentPage++; },
      goToPage(){},
      async fetchPlayers(){
        try{
          const resp = await axios.get('https://worker-production-1ad2.up.railway.app/api/players', { timeout: 10000 });
          const sorted = (resp.data || []).slice().sort((a,b)=> (b.mmr||0) - (a.mmr||0));
          this.players = sorted;
          const map = {}; sorted.forEach((p,i)=> map[p.id] = i+1); this.playerRankMap = map;
        }catch(err){
          console.error('API players error:', err?.message || err);
          // demo fallback
          const demo = Array.from({length:60}).map((_,i)=>({
            id:'demo'+i, name: i%7===0? 'usuario123' : ('usuario'+(100+i)),
            mmr: 1000 - i*7,
            rank: ['Gold','Platinum','Diamond','Bronze','Silver','Master','Legend'][i%7],
            country: i%2===0?'pe':'us',
            verified: i%11!==0
          })).sort((a,b)=> b.mmr - a.mmr);
          const map = {}; demo.forEach((p,i)=> map[p.id]=i+1);
          this.players = demo; this.playerRankMap = map;
        }
      },
      async fetchPfpMap(){
        try{
          if(window.loadPfpMap){
            this.pfpMap = await window.loadPfpMap();
          }
        }catch(e){ console.warn('PFP map error', e); }
      },
      flagUrl(cc){ return `https://flagcdn.com/24x18/${String(cc||'').toLowerCase()}.png`; },
      displayRank(rank){ return rank==='GrandChampion' ? 'Grand Champion' : rank; },
      splitName(name){
        const emojiPres = /\p{Emoji_Presentation}/u;
        return Array.from(String(name||'')).map(c=>({ char:c, isEmoji: emojiPres.test(c) }));
      },
      onDocClick(e){
        const dd = document.querySelector('#lbApp .dropdown');
        if(!dd?.contains(e.target)) this.menuOpen = false;
      }
    },
    async mounted(){
      await this.fetchPlayers();
      await this.fetchPfpMap();
      this._timer = setInterval(this.fetchPlayers, 10000);
      document.addEventListener('click', this.onDocClick);
    },
    unmounted(){
      if(this._timer) clearInterval(this._timer);
      document.removeEventListener('click', this.onDocClick);
    }
  }).mount('#lbApp');
</script>

<!-- Firebase + Auth + Discord OAuth (popup) + PFP -->
<!-- OPCIONAL: pega tu config aquí para evitar editar el JS -->
<script id="fb-config" type="application/json">
{
  "apiKey": "TU_API_KEY",
  "authDomain": "TU_AUTH_DOMAIN",
  "projectId": "TU_PROJECT_ID",
  "storageBucket": "TU_BUCKET",
  "messagingSenderId": "TU_SENDER_ID",
  "appId": "TU_APP_ID"
}
</script>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
  import {
    getAuth, onAuthStateChanged, createUserWithEmailAndPassword, signInWithEmailAndPassword,
    sendEmailVerification, sendPasswordResetEmail, signOut, updateProfile,
    setPersistence, browserLocalPersistence
  } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
  import {
    getFirestore, doc, setDoc, updateDoc, getDoc, getDocs, collection, serverTimestamp, query, limit, Timestamp
  } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

  // ========== CONFIG FIREBASE (con validación) ==========
  // 1) Lee desde el script fb-config (recomendado para no tocar JS)
  let externalCfg = {};
  try {
    const node = document.getElementById('fb-config');
    if (node?.textContent) externalCfg = JSON.parse(node.textContent);
  } catch {}

  // 2) Fallback si no se usa fb-config:
  const firebaseConfig = {
    apiKey: externalCfg.apiKey || "TU_API_KEY",
    authDomain: externalCfg.authDomain || "TU_AUTH_DOMAIN",
    projectId: externalCfg.projectId || "TU_PROJECT_ID",
    storageBucket: externalCfg.storageBucket || "TU_BUCKET",
    messagingSenderId: externalCfg.messagingSenderId || "TU_SENDER_ID",
    appId: externalCfg.appId || "TU_APP_ID",
  };

  function isPlaceholder(v){ return !v || /^TU_/.test(v) || v === "TU_BUCKET" || v === "TU_SENDER_ID" || v === "TU_APP_ID"; }
  function ensureValidFirebaseConfig(cfg){
    const bad = Object.entries(cfg).filter(([k,v])=>isPlaceholder(v)).map(([k])=>k);
    if (bad.length){
      const msg = `Config de Firebase inválida. Faltan: ${bad.join(", ")}.
      Coloca tus credenciales reales en <script id="fb-config">…</script> o en la constante firebaseConfig.`;
      const box = document.getElementById('configError');
      if (box){ box.style.display='block'; box.textContent = msg; }
      // Deshabilitar acciones de auth para evitar errores confusos
      ["btnLogin","btnRegister","btnLoginDiscord","btnRegisterDiscord","btnReset","btnResendFromLogin"].forEach(id=>{
        const el = document.getElementById(id); if(el){ el.disabled = true; el.classList.add('disabled'); }
      });
      return false;
    }
    return true;
  }

  const cfgOK = ensureValidFirebaseConfig(firebaseConfig);
  const app  = cfgOK ? initializeApp(firebaseConfig) : null;
  const auth = cfgOK ? getAuth(app) : null;
  const db   = cfgOK ? getFirestore(app) : null;
  if (auth) await setPersistence(auth, browserLocalPersistence);

  // ========== Utilidades UI ==========
  const $  = (sel)=>document.querySelector(sel);
  const $$ = (sel)=>Array.from(document.querySelectorAll(sel));
  const show = (el,on=true)=> el && (el.style.display = on ? "" : "none");
  function showMsg(el, text, type){ el.className = "msg " + (type||"info"); el.textContent = text; el.style.display = text ? "block" : "none"; }

  function validateDiscord(u){
    if(!u) return false;
    u = u.trim().replace(/^@/,'');
    const legacy = /^[^\s@#]{2,32}#[0-9]{4}$/;
    const modern = /^[a-zA-Z0-9._]{2,32}$/;
    return legacy.test(u) || modern.test(u);
  }
  const genCode=()=> Math.random().toString(36).slice(2,8).toUpperCase();

  // ===== Tabs
  function setActiveTab(name){
    $$(".tabbtn").forEach(b=>b.classList.toggle("active", b.dataset.tab===name));
    $$("main section").forEach(s=>s.classList.toggle("active", s.id===name));
    if(name === 'profile') checkProfileAccess();
  }
  $("#tabs").addEventListener("click",(e)=>{
    const btn = e.target.closest(".tabbtn");
    if(!btn) return;
    setActiveTab(btn.dataset.tab);
  });

  // ===== Discord OAuth (popup)
  const OAUTH_URL = "https://TU_BACKEND/oauth/discord/start";
  async function openDiscord(flow){
    if(!auth?.currentUser){ alert("Primero inicia sesión o regístrate."); return; }
    const uid = auth.currentUser.uid;
    window.open(`${OAUTH_URL}?uid=${encodeURIComponent(uid)}&flow=${flow}`, "_blank", "width=520,height=650");
  }
  $("#btnLoginDiscord")?.addEventListener("click",()=>openDiscord("login"));
  $("#btnRegisterDiscord")?.addEventListener("click",()=>openDiscord("register"));

  // Validación de coincidencia de nombre al volver del OAuth
  async function enforceDiscordMatch(uid){
    const udoc = await getDoc(doc(db,"users",uid));
    const vdoc = await getDoc(doc(db,"verifications",uid));
    const showName = udoc.exists()? (udoc.data().showName || udoc.data().discordName) : null;
    const discordName = vdoc.exists()? vdoc.data().discordName : null;
    if(!showName || !discordName) return false;
    const ok = String(showName).trim().toLowerCase() === String(discordName).trim().toLowerCase();
    if(!ok){
      await setDoc(doc(db,"verifications",uid), { discordVerified:false, mismatch:true }, {merge:true});
      showMsg($("#welcomeMsg"), "El Discord autorizado no coincide con tu username/showname registrado.", "err");
    }
    return ok;
  }

  // Mensajes post-OAuth
  window.addEventListener("message", async (ev)=>{
    if(ev.data === "discord-linked" && auth?.currentUser){
      const ok = await enforceDiscordMatch(auth.currentUser.uid);
      const vdoc = await getDoc(doc(db,"verifications",auth.currentUser.uid));
      hydrateVerifyUI({
        discordVerified: ok && vdoc.exists() ? !!vdoc.data().discordVerified : ok,
        emailVerified: auth.currentUser.emailVerified,
        code: vdoc.exists()? vdoc.data().code : $("#discCode").textContent,
        emailDeadline: vdoc.exists()? vdoc.data().emailDeadline : null,
        showName: (await getDoc(doc(db,"users",auth.currentUser.uid))).data()?.showName || "usuario123"
      });
      if(!ok) setActiveTab("home");
    }
    if(ev.data === "discord-failed"){
      showMsg($("#welcomeMsg"), "failed to verificate", "err");
    }
  });

  // ===== Auth: Register
  $("#btnRegister")?.addEventListener("click", async ()=>{
    if(!auth) return;
    const discord = $("#regDiscord").value.trim();
    const email   = $("#regEmail").value.trim();
    const pass    = $("#regPass").value.trim();
    const el = $("#regMsg"); showMsg(el,"","info");
    if(!discord || !email || !pass){ showMsg(el,"Completa Discord/Showname, email y contraseña.","err"); return; }
    if(!validateDiscord(discord)){ showMsg(el,"Discord/Showname inválido.","err"); return; }
    try{
      const cred = await createUserWithEmailAndPassword(auth, email, pass);
      const user = cred.user;
      await updateProfile(user, { displayName: discord });
      await setDoc(doc(db,"users",user.uid), {
        uid:user.uid, email, showName: discord, discordName: discord,
        emailVerified: user.emailVerified || false,
        discordVerified: false, pfpUrl:"", createdAt:serverTimestamp(), updatedAt:serverTimestamp()
      }, {merge:true});
      const {code}=await createOrRefreshCode(user.uid, true);
      // Email verification + deadline 5 min
      await sendEmailVerification(user);
      const deadline = Timestamp.fromDate(new Date(Date.now()+5*60*1000));
      await setDoc(doc(db,"verifications",user.uid), { emailDeadline: deadline }, {merge:true});
      show($("#authArea"), false); show($("#welcomeArea"), true);
      hydrateVerifyUI({discordVerified:false, emailVerified:false, code, emailDeadline:deadline, showName:discord});
      showMsg(el,"Cuenta creada. Completa verificación (Discord requerido para PFP).", "ok");
    }catch(err){
      const map={"auth/email-already-in-use":"Ese email ya está registrado.","auth/invalid-email":"Email inválido.","auth/weak-password":"La contraseña es muy débil (mínimo 6)."};
      showMsg(el, map[err.code] || ("Error al registrar: "+err.message), "err");
    }
  });

  // ===== Auth: Login
  $("#btnLogin")?.addEventListener("click", async ()=>{
    if(!auth) return;
    const discord = $("#loginDiscord").value.trim();
    const email   = $("#loginEmail").value.trim();
    const pass    = $("#loginPass").value.trim();
    const el = $("#loginMsg"); showMsg(el,"","info");
    if(!discord || !email || !pass){ showMsg(el,"Completa Discord/Showname, email y contraseña.","err"); return; }
    try{
      const cred = await signInWithEmailAndPassword(auth, email, pass);
      const user = cred.user;
      await ensureUserDiscord(user.uid, discord);
      const {code}=await createOrRefreshCode(user.uid, false);
      // Auto-enviar verificación de email al hacer login si aún no está verificado (y programar 5 min)
      if(!user.emailVerified){
        await sendEmailVerification(user);
        const deadline = Timestamp.fromDate(new Date(Date.now()+5*60*1000));
        await setDoc(doc(db,"verifications",user.uid), { emailDeadline: deadline }, {merge:true});
      }
      await user.reload();
      const vdoc = await getDoc(doc(db,"verifications",user.uid));
      const v = vdoc.exists() ? vdoc.data() : {discordVerified:false, emailVerified:user.emailVerified};
      show($("#authArea"), false); show($("#welcomeArea"), true);
      hydrateVerifyUI({
        discordVerified: !!v.discordVerified,
        emailVerified: user.emailVerified,
        code,
        emailDeadline: v.emailDeadline || null,
        showName: discord
      });
      showMsg(el,"Login correcto. Vincula Discord si aún no lo hiciste para poder usar PFP.", "ok");
    }catch(err){
      const map={"auth/invalid-email":"Email inválido.","auth/user-disabled":"Usuario deshabilitado.","auth/user-not-found":"No existe cuenta con ese email.","auth/wrong-password":"Contraseña incorrecta."};
      showMsg(el, map[err.code] || ("Error al iniciar sesión: "+err.message), "err");
    }
  });

  $("#btnReset")?.addEventListener("click", async ()=>{
    if(!auth) return;
    const email = $("#loginEmail").value.trim() || prompt("Escribe tu email para enviar el reset:");
    if(!email) return;
    try{ await sendPasswordResetEmail(auth,email); showMsg($("#loginMsg"),"Te enviamos un correo para resetear tu contraseña.","ok"); }
    catch(err){ showMsg($("#loginMsg"),"No pudimos enviar el reset: "+err.message,"err"); }
  });

  $("#btnResendFromLogin")?.addEventListener("click", async ()=>{
    if(!auth?.currentUser){ showMsg($("#loginMsg"),"Primero inicia sesión.","err"); return; }
    try{
      await sendEmailVerification(auth.currentUser);
      const deadline = Timestamp.fromDate(new Date(Date.now()+5*60*1000));
      await setDoc(doc(db,"verifications",auth.currentUser.uid), { emailDeadline: deadline }, {merge:true});
      showMsg($("#loginMsg"),"Correo reenviado (caduca en 5 min).","ok");
      hydrateVerifyUI({emailVerified:false, discordVerified:false, code: $("#discCode").textContent, emailDeadline:deadline, showName: auth.currentUser.displayName || ""});
    }
    catch(err){ showMsg($("#loginMsg"),"No se pudo reenviar: "+err.message,"err"); }
  });

  onAuthStateChanged(auth, async (user)=>{
    if(user){
      const udoc = await getDoc(doc(db,"users",user.uid));
      const vdoc = await getDoc(doc(db,"verifications",user.uid));
      const showName = udoc.exists() ? (udoc.data().showName || user.displayName || user.email.split("@")[0]) : (user.displayName || user.email.split("@")[0]);
      let code = vdoc.exists() ? (vdoc.data().code) : genCode();
      if(!vdoc.exists()){
        await setDoc(doc(db,"verifications",user.uid), {
          uid:user.uid, discordName:showName, code, discordVerified:false, emailVerified:user.emailVerified, codeCreatedAt: serverTimestamp()
        }, {merge:true});
      }
      show($("#authArea"), false); show($("#welcomeArea"), true);
      hydrateVerifyUI({
        discordVerified: vdoc.exists()? !!vdoc.data().discordVerified : false,
        emailVerified: user.emailVerified,
        code,
        emailDeadline: vdoc.exists()? vdoc.data().emailDeadline : null,
        showName
      });
    }else{
      show($("#welcomeArea"), false); show($("#authArea"), true);
    }
  });

  $("#btnResendVerify")?.addEventListener("click", async ()=>{
    if(!auth?.currentUser) return;
    try{
      await sendEmailVerification(auth.currentUser);
      const deadline = Timestamp.fromDate(new Date(Date.now()+5*60*1000));
      await setDoc(doc(db,"verifications",auth.currentUser.uid), { emailDeadline: deadline }, {merge:true});
      showMsg($("#welcomeMsg"),"Correo de verificación reenviado (caduca en 5 min).","ok");
      startEmailCountdown(deadline);
    }catch(err){ showMsg($("#welcomeMsg"),"No se pudo reenviar: "+err.message,"err"); }
  });
  $("#btnIHaveVerified")?.addEventListener("click", async ()=>{
    if(!auth?.currentUser) return;
    await auth.currentUser.reload();
    const vdoc = await getDoc(doc(db,"verifications",auth.currentUser.uid));
    const udoc = await getDoc(doc(db,"users",auth.currentUser.uid));
    hydrateVerifyUI({
      discordVerified: vdoc.exists()? !!vdoc.data().discordVerified : false,
      emailVerified: auth.currentUser.emailVerified,
      code: vdoc.exists()? vdoc.data().code : "------",
      emailDeadline: vdoc.exists()? vdoc.data().emailDeadline : null,
      showName: udoc.exists()? udoc.data().showName : "usuario123"
    });
  });

  $("#btnCopyCode")?.addEventListener("click", ()=>{
    const code = $("#discCode").textContent.trim();
    navigator.clipboard.writeText(code);
    showMsg($("#welcomeMsg"),"Código copiado.","ok");
  });

  $("#btnRegenCode")?.addEventListener("click", async ()=>{
    if(!auth?.currentUser) return;
    const {code}=await createOrRefreshCode(auth.currentUser.uid,true);
    $("#discCode").textContent = code;
    showMsg($("#welcomeMsg"),"Nuevo código generado.","ok");
  });

  $("#btnGoProfile")?.addEventListener("click", ()=> setActiveTab("profile"));
  $("#btnLogout")?.addEventListener("click", async ()=>{ if(auth) await signOut(auth); setActiveTab("home"); });

  async function ensureUserDiscord(uid, discord){
    const uref = doc(db,"users",uid);
    const snap = await getDoc(uref);
    if(!snap.exists() || (snap.data().showName||"") !== discord){
      await setDoc(uref,{ showName:discord, discordName:discord, updatedAt:serverTimestamp() },{merge:true});
    }
  }

  async function createOrRefreshCode(uid, regenerate){
    const vref=doc(db,"verifications",uid); const v=await getDoc(vref);
    const newCode=genCode(); const expiresAt = Timestamp.fromDate(new Date(Date.now()+5*60*1000));
    if(!v.exists() || regenerate){
      await setDoc(vref,{ uid, code:newCode, expiresAt, discordVerified:false },{merge:true});
      return { code:newCode, expiresAt};
    }
    const d=v.data(); return { code: d.code||newCode, expiresAt: d.expiresAt || expiresAt };
  }

  // Countdown UI para email (5 min)
  let emailTimerHandle = null;
  function startEmailCountdown(deadlineTs){
    clearInterval(emailTimerHandle);
    if(!deadlineTs){ $("#emailTimer").textContent = "—:—"; return; }
    function tick(){
      const left = deadlineTs.toMillis() - Date.now();
      if(left <= 0){ $("#emailTimer").textContent = "00:00"; clearInterval(emailTimerHandle); return; }
      const m = Math.floor(left/60000), s = Math.floor((left%60000)/1000);
      $("#emailTimer").textContent = `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    }
    tick();
    emailTimerHandle = setInterval(tick, 1000);
  }

  function hydrateVerifyUI({discordVerified, emailVerified, code, emailDeadline, showName}){
    $("#welcomeName").textContent = showName || "usuario123";
    $("#discCode").textContent = code || "------";
    $("#discBadge").textContent = discordVerified ? "Verificado" : "Pendiente";
    $("#discBadge").className = "badge" + (discordVerified ? " ok" : "");
    $("#mailBadge").textContent = emailVerified ? "Verificado" : "Pendiente";
    $("#mailBadge").className = "badge" + (emailVerified ? " ok" : "");
    startEmailCountdown(emailDeadline || null);

    // Acceso a PFP SOLO por Discord
    if(discordVerified){
      showMsg($("#welcomeMsg"),"Discord verificado. Ya puedes ir a Edit Profile para elegir tu PFP.","ok");
    }else{
      showMsg($("#welcomeMsg"),"Vincula y autoriza tu Discord para habilitar Edit Profile.","info");
    }
    checkProfileAccess(discordVerified);
  }

  // ========= PFP: catálogo =========
  const IMAGE_BASES = [
    "https://sekai-res.dnaroma.eu/file/sekai-assets/thumbnail/chara_card/",
    "https://storage.sekai.best/sekai-assets/thumbnail/chara_card/",
  ];
  const CARD_APIS = [
    "https://raw.githubusercontent.com/Sekai-World/sekai-master-db-diff/master/cards.json",
    "https://sekai.best/api/v2/cards.json",
    "https://sekai.best/api/cards.json",
  ];

  function urlsFromAsset(assetbundleName){
    const normal  = `${assetbundleName}_normal.png`;
    const trained = `${assetbundleName}_after_training.png`;
    return { normal: IMAGE_BASES[0]+normal, trained: IMAGE_BASES[0]+trained };
  }
  function normalizeCard(c){
    const asset = c.assetbundleName || c.assetBundleName || c.assetbundle || c.assetBundle;
    const id    = c.id || c.cardId || c.resourceId || c.seq || c.card_id || asset;
    const name  = c.name || c.title || c.cardName || "";
    if(!asset) return null;
    const u = urlsFromAsset(asset);
    return { id: id??asset, name, assetbundleName: asset, imgNormal:u.normal, imgTrained:u.trained };
  }

  const statePFP = { cards:[], filtered:[], version:"both", search:"" };

  async function fetchCards(){
    const info = $("#pfpInfo");
    showMsg(info,"Cargando cartas…","info");
    let ok=false, raw=null;
    for(const api of CARD_APIS){
      try{
        const res = await fetch(api, { mode:"cors", cache:"no-store" });
        if(res.ok){ raw = await res.json(); ok=true; break; }
      }catch{}
    }
    if(!ok){
      showMsg(info,"No pudimos leer la lista de cartas desde sekai.best / GitHub. Usa la URL manual temporalmente.","err");
      return;
    }
    const list = Array.isArray(raw) ? raw : (raw.data||raw.cards||raw.result||[]);
    const mapped = [];
    for(const item of list){ const m = normalizeCard(item); if(m) mapped.push(m); }
    statePFP.cards = mapped;
    filterCards(); renderCardGrid();
    showMsg(info,`Cartas cargadas: ${mapped.length}.`, "ok");
  }

  function filterCards(){
    const q = statePFP.search.toLowerCase();
    const ver=statePFP.version;
    statePFP.filtered = statePFP.cards.filter(c=>{
      return (c.name||"").toLowerCase().includes(q) || String(c.id).toLowerCase().includes(q) || c.assetbundleName.toLowerCase().includes(q);
    }).map(c=>{
      if(ver==="normal") return [{...c,show:"normal"}];
      if(ver==="trained") return [{...c,show:"trained"}];
      return [{...c,show:"normal"},{...c,show:"trained"}];
    }).flat();
  }
  function renderCardGrid(){
    const grid = $("#pfpGrid");
    if(statePFP.filtered.length===0){ grid.innerHTML = `<div class="help">Sin resultados. Prueba otro término.</div>`; return; }
    grid.innerHTML = statePFP.filtered.map(c=>{
      const img = c.show==="trained" ? c.imgTrained : c.imgNormal;
      const ver = c.show==="trained" ? "Trained" : "Normal";
      return `
        <div class="card-tile" data-url="${img}" data-asset="${c.assetbundleName}">
          <img class="tile-img" loading="lazy" src="${img}" alt="#${c.id}">
          <div class="tile-meta">
            <span class="badge">${ver}</span>
            <span>#${c.id}</span>
          </div>
        </div>`;
    }).join("");
    $$(".card-tile").forEach(tile=>{
      tile.addEventListener("click", ()=> setPfpUrl(tile.dataset.url));
    });
  }

  $("#pfpVersion")?.addEventListener("change", ()=>{ statePFP.version=$("#pfpVersion").value; filterCards(); renderCardGrid(); });
  $("#pfpSearch")?.addEventListener("input",  ()=>{ statePFP.search=$("#pfpSearch").value.trim().toLowerCase(); filterCards(); renderCardGrid(); });

  $("#btnSetManual")?.addEventListener("click", async ()=>{
    const url = $("#manualUrl").value.trim();
    if(!url) return;
    await setPfpUrl(url);
  });

  $("#btnClearPfp")?.addEventListener("click", async ()=>{
    if(!auth?.currentUser) return;
    await updateDoc(doc(db,"users",auth.currentUser.uid), { pfpUrl:"", updatedAt:serverTimestamp() });
    const key = await getDisplayKey(auth.currentUser.uid);
    await setDoc(doc(db,"pfps", key), { url:"", updatedAt: serverTimestamp(), by:auth.currentUser.uid }, {merge:true});
    alert("PFP eliminado.");
  });

  async function getDisplayKey(uid){
    const s = await getDoc(doc(db,"users",uid));
    const showName = s.exists()? (s.data().showName || s.data().discordName || auth.currentUser.displayName || auth.currentUser.email.split("@")[0]) : (auth.currentUser.displayName || auth.currentUser.email.split("@")[0]);
    return String(showName||"").toLowerCase();
  }

  async function setPfpUrl(url){
    if(!auth?.currentUser){ setActiveTab("home"); alert("Inicia sesión."); return; }
    // Gate: requiere Discord verificado
    const vdoc = await getDoc(doc(db,"verifications",auth.currentUser.uid));
    if(!vdoc.exists() || !vdoc.data().discordVerified){
      alert("Debes vincular y autorizar tu Discord primero.");
      return;
    }
    await updateDoc(doc(db,"users",auth.currentUser.uid), { pfpUrl:url, updatedAt:serverTimestamp() });
    const key = await getDisplayKey(auth.currentUser.uid);
    await setDoc(doc(db,"pfps", key), { url, updatedAt: serverTimestamp(), by:auth.currentUser.uid }, {merge:true});
    alert("PFP actualizado ✔");
  }

  // Exponer para Vue (leaderboard)
  window.loadPfpMap = async function(){
    const snap = await getDocs(query(collection(db,"pfps"), limit(2000)));
    const map = {};
    snap.forEach(d=>{
      const url = (d.data().url||"").trim();
      if(url) map[d.id] = url;
    });
    return map;
  }

  // ===== Gate de Profile (siempre clickeable la pestaña)
  async function checkProfileAccess(forceDiscordOk){
    const content = $("#profileContent");
    const gate    = $("#profileGate");
    if(!auth?.currentUser){
      show(gate,true); show(content,false); return;
    }
    const vdoc = await getDoc(doc(db,"verifications",auth.currentUser.uid));
    const ok = typeof forceDiscordOk === "boolean" ? forceDiscordOk : (vdoc.exists() && !!vdoc.data().discordVerified);
    show(gate,!ok); show(content,ok);
  }

  // start
  if (cfgOK) fetchCards();
</script>
</body>
</html>



